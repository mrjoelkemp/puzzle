// Generated by CoffeeScript 1.3.1
(function() {

  this.Jigsaw = (function() {

    function Jigsaw() {
      var back_canvas, back_canvas_context, back_canvas_element, board, columns, neighbors, pieces, pieces_canvas, player, refresh_rate, rows, snapping_threshold, starting_id, video_element;
      player = $('#player');
      video_element = $('#player')[0];
      video_element.muted = true;
      back_canvas = $('#back-canvas');
      pieces_canvas = $("#pieces-canvas");
      rows = 2;
      columns = 3;
      starting_id = 1;
      board = Board.initBoard(rows, columns, starting_id);
      neighbors = this.initNeighbors(rows, columns, board);
      pieces = PieceManager.initPieces(rows, columns, back_canvas, starting_id, neighbors);
      snapping_threshold = 40;
      this.setDraggingEvents(pieces, snapping_threshold);
      PieceManager.randomize(pieces);
      refresh_rate = 33;
      back_canvas_element = back_canvas[0];
      back_canvas_context = back_canvas_element.getContext('2d');
      this.renderVideoToBackCanvas(video_element, back_canvas_context, refresh_rate);
      this.renderBackCanvasToPieces(back_canvas_element, pieces, refresh_rate);
    }

    Jigsaw.prototype.setDraggingEvents = function(pieces, snapping_threshold) {
      var _this = this;
      return _.each(pieces, function(piece) {
        piece.draggable({
          helper: "original",
          snap: false,
          snapMode: "inner",
          stack: ".piece",
          snapTolerance: snapping_threshold
        });
        piece.bind("dragstart", function(e, ui) {
          return Piece.onDragStart(e, ui, piece);
        });
        piece.bind("drag", function(e, ui) {
          return Piece.onDrag(e, ui, piece, pieces);
        });
        return piece.bind("dragstop", function(e, ui) {
          return _this.onDragStop(piece, pieces, snapping_threshold);
        });
      });
    };

    Jigsaw.prototype.onDragStop = function(piece, pieces, snapping_threshold) {
      var have_neighbors_to_snap, neighbors_objects, snappable_neighbors, snappable_neighbors_ids,
        _this = this;
      Piece.updateDetailedPosition(piece);
      neighbors_objects = Piece.getNeighborObjects(piece, pieces);
      _.each(neighbors_objects, function(n) {
        return Piece.updateDetailedPosition(n);
      });
      snappable_neighbors_ids = this.findSnappableNeighbors(piece, neighbors_objects, snapping_threshold);
      snappable_neighbors = Piece.getNeighborObjectsFromIds(pieces, snappable_neighbors_ids);
      have_neighbors_to_snap = !_.isEmpty(snappable_neighbors);
      if (have_neighbors_to_snap) {
        this.propagateSnap(piece, snappable_neighbors, pieces);
        this.snapToNeighbors(piece, snappable_neighbors);
        return this.checkWinCondition(pieces);
      }
    };

    Jigsaw.prototype.checkWinCondition = function(pieces) {
      var g_id, game_won, group_members, num_pieces;
      num_pieces = _.size(pieces);
      g_id = pieces[1].data("group");
      group_members = _.filter(pieces, function(p) {
        return p.data("group") === g_id;
      });
      game_won = num_pieces === _.size(group_members);
      if (game_won) {
        return this.updateGameStatus("You Win!");
      }
    };

    Jigsaw.prototype.updateGameStatus = function(msg) {
      return $('#game-status').html("<span>" + msg + "</span>").addClass("win");
    };

    Jigsaw.prototype.propagateSnap = function(piece, snappable_neighbors, pieces) {
      var p_gid,
        _this = this;
      p_gid = piece.data("id");
      piece.data("group", p_gid);
      _.each(snappable_neighbors, function(n) {
        var has_group, n_gid, n_group_members;
        n_gid = n.data("group");
        has_group = n_gid !== -1;
        if (has_group) {
          n_group_members = Piece.getGroupObjects(n_gid, n, pieces);
          return _.each(n_group_members, function(ngm) {
            return ngm.data("group", p_gid);
          });
        }
      });
      return _.each(snappable_neighbors, function(sn) {
        return sn.data("group", p_gid);
      });
    };

    Jigsaw.prototype.debug_colorObjectsFromId = function(pieces) {
      var colors;
      colors = ["red", "green", "blue", "yellow", "black", "pink"];
      return _.each(pieces, function(p) {
        var p_gid;
        p_gid = p.data("group");
        return p.css("border", "3px solid " + colors[p_gid]);
      });
    };

    Jigsaw.prototype.snapToNeighbors = function(current_piece, snappable_neighbors) {
      var neighbors_points, neighbors_relations, objects_relations,
        _this = this;
      neighbors_relations = Piece.getNeighborRelations(current_piece, snappable_neighbors);
      objects_relations = _.zip(snappable_neighbors, neighbors_relations);
      neighbors_points = _.map(objects_relations, function(arr) {
        var neighbor, relation;
        neighbor = arr[0];
        relation = arr[1];
        return _this.getSnappablePoints(current_piece, neighbor, relation);
      });
      return _.each(neighbors_points, function(points) {
        var left_offset, offsets, top_offset;
        offsets = Piece.getMovementOffset(points[0], points[1], points[2], points[3]);
        left_offset = offsets.left_offset;
        top_offset = offsets.top_offset;
        return Piece.movePieceByOffsets(current_piece, left_offset, top_offset, 0);
      });
    };

    Jigsaw.prototype.findSnappableNeighbors = function(current_piece, neighbors_objects, snapping_threshold) {
      var i, neighbor_id, neighbor_object, neighbor_relation, neighbors_objects_ids, neighbors_relations, snappable, snaps, _i, _ref;
      neighbors_relations = Piece.getNeighborRelations(current_piece, neighbors_objects);
      snappable = [];
      neighbors_objects_ids = _.map(neighbors_objects, function(n) {
        return n.data("id");
      });
      for (i = _i = 0, _ref = neighbors_objects_ids.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        neighbor_id = neighbors_objects_ids[i];
        neighbor_object = neighbors_objects[i];
        neighbor_relation = neighbors_relations[i];
        snaps = this.canSnap(current_piece, neighbor_object, neighbor_relation, snapping_threshold);
        if (snaps) {
          snappable.push(neighbor_id);
        }
      }
      return snappable;
    };

    Jigsaw.prototype.canSnap = function(current_piece, neighbor_object, neighbor_relation, snapping_threshold) {
      var points, snappable;
      points = this.getSnappablePoints(current_piece, neighbor_object, neighbor_relation);
      snappable = MathHelper.isWithinThreshold(points[0], points[1], points[2], points[3], snapping_threshold);
      return snappable;
    };

    Jigsaw.prototype.getSnappablePoints = function(current_piece, neighbor_piece, neighbor_relation) {
      var cp, np, points;
      cp = current_piece.data("position");
      np = neighbor_piece.data("position");
      points = [];
      switch (neighbor_relation) {
        case "right":
          points = [cp.top_right, cp.bottom_right, np.top_left, np.bottom_left];
          break;
        case "left":
          points = [cp.top_left, cp.bottom_left, np.top_right, np.bottom_right];
          break;
        case "top":
          points = [cp.top_left, cp.top_right, np.bottom_left, np.bottom_right];
          break;
        case "bottom":
          points = [cp.bottom_left, cp.bottom_right, np.top_left, np.top_right];
      }
      return points;
    };

    Jigsaw.prototype.initNeighbors = function(rows, columns, board) {
      var bottom, bottom_bound, col, current_position_id, left, left_bound, neighbors, right, right_bound, row, top, top_bound, _i, _j, _ref, _ref1;
      neighbors = {};
      left_bound = 0;
      top_bound = 0;
      right_bound = columns - 1;
      bottom_bound = rows - 1;
      for (row = _i = 0, _ref = rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
        left = void 0;
        right = void 0;
        top = void 0;
        bottom = void 0;
        for (col = _j = 0, _ref1 = columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          left = col !== left_bound ? board[row][col - 1] : void 0;
          top = row !== top_bound ? board[row - 1][col] : void 0;
          right = col !== right_bound ? board[row][col + 1] : void 0;
          bottom = row !== bottom_bound ? board[row + 1][col] : void 0;
          current_position_id = board[row][col];
          neighbors[current_position_id] = {
            "left": left,
            "right": right,
            "top": top,
            "bottom": bottom
          };
        }
      }
      return neighbors;
    };

    Jigsaw.prototype.renderVideoToBackCanvas = function(video_element, back_canvas_context, refresh_rate, pieces) {
      var _this = this;
      return setInterval(function() {
        video_element.play();
        return back_canvas_context.drawImage(video_element, 0, 0);
      }, refresh_rate);
    };

    Jigsaw.prototype.renderBackCanvasToPieces = function(back_canvas_element, pieces, refresh_rate) {
      var pieces_objects,
        _this = this;
      pieces_objects = _.values(pieces);
      return setInterval(function() {
        return _.each(pieces_objects, function(piece) {
          var height, piece_context, videox, videoy, width;
          piece_context = piece[0].getContext('2d');
          videox = parseFloat(piece.attr("videox"));
          videoy = parseFloat(piece.attr("videoy"));
          width = parseFloat(piece.attr("width"));
          height = parseFloat(piece.attr("height"));
          return piece_context.drawImage(back_canvas_element, videox, videoy, width, height, 0, 0, width, height);
        });
      }, refresh_rate);
    };

    return Jigsaw;

  })();

}).call(this);
